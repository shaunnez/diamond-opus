name: Deploy Production

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to deploy (branch, tag, or SHA)"
        required: false
        default: "main"
      skip_build:
        description: "Skip build and use existing images from staging"
        required: false
        type: boolean
        default: false

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    environment: production
    if: ${{ !inputs.skip_build }}

    strategy:
      matrix:
        app: [api, scheduler, worker, consolidator, dashboard]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.ACR_LOGIN_SERVER }}/diamond-${{ matrix.app }}
          tags: |
            type=sha,format=short,prefix=
            type=raw,value=production
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile.${{ matrix.app }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: ${{ always() && (needs.build-and-push.result == 'success' || inputs.skip_build) }}
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Azure Login
        uses: Azure/login@v2.3.0
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}'

      - name: Get commit SHA
        id: sha
        run: echo "short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Determine image tag
        id: tag
        run: |
          if [ "${{ inputs.skip_build }}" = "true" ]; then
            echo "tag=staging" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ steps.sha.outputs.short }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Container Apps
        env:
          RESOURCE_GROUP: diamond-prod-rg
          ENVIRONMENT: ${{ secrets.AZURE_CONTAINER_APP_ENV_PROD }}
          ACR_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
          IMAGE_TAG: ${{ steps.tag.outputs.tag }}
        run: |
          # Helper function to update an existing container app (created by Terraform)
          # This workflow only updates images - Terraform manages container creation with env vars
          deploy_app() {
            local name=$1
            local container_name=$2
            local image=$3

            if az containerapp show --name "$name" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
              echo "Updating existing app: $name (container: $container_name)"
              az containerapp update \
                --name "$name" \
                --resource-group "$RESOURCE_GROUP" \
                --container-name "$container_name" \
                --image "$image"
            else
              echo "WARNING: Container app '$name' does not exist - skipping."
              echo "Container apps must be created by Terraform (infrastructure.yml) with proper environment variables."
              echo "Run 'terraform apply' in infrastructure/terraform/environments/prod to create the container."
            fi
          }

          # Deploy API (container name 'api' as defined in Terraform)
          deploy_app "diamond-prod-api" "api" "$ACR_SERVER/diamond-api:$IMAGE_TAG"

          # Deploy Worker (container name 'worker' as defined in Terraform)
          deploy_app "diamond-prod-worker" "worker" "$ACR_SERVER/diamond-worker:$IMAGE_TAG"

          # Deploy Consolidator (container name 'consolidator' as defined in Terraform)
          deploy_app "diamond-prod-consolidator" "consolidator" "$ACR_SERVER/diamond-consolidator:$IMAGE_TAG"

          # Scheduler is managed by Terraform (infrastructure.yml) with Schedule trigger
          # Only update the image if the job exists, don't create it here
          if az containerapp job show --name "diamond-prod-scheduler" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
            echo "Updating scheduler job image"
            az containerapp job update \
              --name "diamond-prod-scheduler" \
              --resource-group "$RESOURCE_GROUP" \
              --container-name "scheduler" \
              --image "$ACR_SERVER/diamond-scheduler:$IMAGE_TAG"
          else
            echo "Scheduler job not found - will be created by Terraform"
          fi

          # Deploy Dashboard (container name 'dashboard' as defined in Terraform)
          deploy_app "diamond-prod-dashboard" "dashboard" "$ACR_SERVER/diamond-dashboard:$IMAGE_TAG"

      - name: Create deployment tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "production-$(date +%Y%m%d-%H%M%S)" -m "Production deployment from ${{ inputs.ref }}"
          git push origin --tags

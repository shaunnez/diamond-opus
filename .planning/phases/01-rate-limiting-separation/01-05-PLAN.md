---
phase: 01-rate-limiting-separation
plan: 05
type: execute
wave: 4
depends_on: [01-03]
files_modified:
  - infrastructure/terraform/modules/container-apps/main.tf
autonomous: true
requirements: [RATE-02]
gap_closure: true

must_haves:
  truths:
    - "Customer API routes Nivoda hold/order requests through ingestion proxy"
    - "NIVODA_PROXY_BASE_URL configured for API Container App"
    - "INTERNAL_SERVICE_TOKEN configured for API Container App"
    - "All Nivoda traffic flows through single rate-limited proxy"
  artifacts:
    - path: "infrastructure/terraform/modules/container-apps/main.tf"
      provides: "API NIVODA_PROXY_BASE_URL env var"
      contains: "NIVODA_PROXY_BASE_URL"
  key_links:
    - from: "azurerm_container_app.api.template.container.env"
      to: "azurerm_container_app.ingestion_proxy.ingress[0].fqdn"
      via: "NIVODA_PROXY_BASE_URL reference"
      pattern: "NIVODA_PROXY_BASE_URL.*ingestion_proxy.*fqdn"
---

<objective>
Configure customer API to route Nivoda hold/order requests through ingestion proxy, closing the rate limiting separation gap.

Purpose: Ensure ALL Nivoda traffic (search/export cached data + hold/order live API calls + ingestion pipeline) flows through single 25 req/s bottleneck.

Output: Customer API env vars updated with NIVODA_PROXY_BASE_URL and INTERNAL_SERVICE_TOKEN.
</objective>

<execution_context>
@/Users/shaunnesbitt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shaunnesbitt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-rate-limiting-separation/01-VERIFICATION.md

# Gap identified in verification
The verification found that customer API holds/orders endpoints need to call Nivoda for real-time operations (creating holds, placing orders). Currently scheduler and worker route through ingestion proxy (plan 01-03), but customer API does NOT.

Missing: Customer API Container App needs NIVODA_PROXY_BASE_URL and INTERNAL_SERVICE_TOKEN env vars (same as scheduler/worker) so that holds/orders endpoints route their Nivoda calls through the ingestion proxy.

Why this matters: Without this, holds/orders bypass the rate limiter entirely and could cause rate limit violations when combined with ingestion traffic.

# Existing Terraform resource
@infrastructure/terraform/modules/container-apps/main.tf

# Nivoda adapter routing logic
@packages/nivoda/src/adapter.ts
@packages/api/src/routes/trading.ts
</context>

<tasks>

<task type="auto">
  <name>Add ingestion proxy routing to customer API</name>
  <files>
infrastructure/terraform/modules/container-apps/main.tf
  </files>
  <action>
Update customer API Container App resource (`azurerm_container_app.api`):

**Add two new env blocks** in the template.container section (after existing NIVODA_* env vars around lines 97-111):

1. NIVODA_PROXY_BASE_URL:
```hcl
env {
  name  = "NIVODA_PROXY_BASE_URL"
  value = "https://${azurerm_container_app.ingestion_proxy.ingress[0].fqdn}"
}
```

2. INTERNAL_SERVICE_TOKEN (already exists as secret, reference it):
```hcl
env {
  name        = "INTERNAL_SERVICE_TOKEN"
  secret_name = "internal-service-token"
}
```

**Placement:** Add after the NIVODA_PASSWORD env block (line 111) and before the HMAC_SECRETS env block.

**How this works:**
When `NIVODA_PROXY_BASE_URL` is set, the Nivoda adapter in `packages/nivoda/src/adapter.ts` (lines 184-197) automatically switches from direct GraphQL client to ProxyGraphqlTransport. The customer API uses this adapter in:
- `packages/api/src/routes/trading.ts` (line 29) for holds/orders operations
- Any other routes that call Nivoda directly

This ensures hold and order API calls are rate-limited through the same proxy as ingestion pipeline.

**Why now:** Plans 01-01 through 01-04 focused on ingestion pipeline separation. This gap closure plan addresses the customer-facing API endpoints (holds/orders) that also need to call Nivoda but were overlooked during initial planning.

**Validation:** Verify INTERNAL_SERVICE_TOKEN env var doesn't already exist in API config (avoid duplicates). Based on grep results, it does NOT currently exist.
  </action>
  <verify>
```bash
# Verify NIVODA_PROXY_BASE_URL added to API
grep -A 2 'name  = "NIVODA_PROXY_BASE_URL"' infrastructure/terraform/modules/container-apps/main.tf | head -10

# Verify it references ingestion_proxy FQDN
grep 'NIVODA_PROXY_BASE_URL' infrastructure/terraform/modules/container-apps/main.tf | grep 'ingestion_proxy'

# Verify INTERNAL_SERVICE_TOKEN added to API
grep -A 2 'secret_name = "internal-service-token"' infrastructure/terraform/modules/container-apps/main.tf | head -10

# Terraform validation
terraform -chdir=infrastructure/terraform/modules/container-apps validate
terraform -chdir=infrastructure/terraform/modules/container-apps fmt -check
```
  </verify>
  <done>
- API env vars include NIVODA_PROXY_BASE_URL pointing to ingestion_proxy.ingress[0].fqdn
- API env vars include INTERNAL_SERVICE_TOKEN secret reference
- No duplicate env var declarations
- Terraform validates successfully
  </done>
</task>

</tasks>

<verification>
Overall plan verification:

```bash
# Verify all three services (scheduler, worker, API) route through proxy
grep 'NIVODA_PROXY_BASE_URL' infrastructure/terraform/modules/container-apps/main.tf | wc -l
# Expected: 3 matches (scheduler, worker, API)

# Verify API specifically has proxy config
awk '/resource "azurerm_container_app" "api"/,/^resource/ {print NR": "$0}' infrastructure/terraform/modules/container-apps/main.tf | grep NIVODA_PROXY_BASE_URL

# Verify API has internal token
awk '/resource "azurerm_container_app" "api"/,/^resource/ {print NR": "$0}' infrastructure/terraform/modules/container-apps/main.tf | grep 'internal-service-token'

# Terraform validation
cd infrastructure/terraform/modules/container-apps
terraform validate
terraform fmt -check
```

Expected output:
- API env vars include NIVODA_PROXY_BASE_URL
- API env vars include INTERNAL_SERVICE_TOKEN
- Terraform validates successfully
- All three services (scheduler, worker, API) route through ingestion proxy
</verification>

<success_criteria>
1. Customer API env vars include NIVODA_PROXY_BASE_URL pointing to ingestion proxy FQDN
2. Customer API env vars include INTERNAL_SERVICE_TOKEN configured
3. No duplicate env var declarations in API config
4. Terraform validates successfully
5. Gap closed: ALL Nivoda traffic (ingestion + holds/orders) routes through single proxy
</success_criteria>

<output>
After completion, create `.planning/phases/01-rate-limiting-separation/01-05-SUMMARY.md`
</output>

---
phase: 01-rate-limiting-separation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ingestion-proxy/src/index.ts
  - apps/ingestion-proxy/src/routes/proxy.ts
  - apps/ingestion-proxy/src/middleware/auth.ts
  - apps/ingestion-proxy/package.json
  - apps/ingestion-proxy/tsconfig.json
  - docker/Dockerfile.ingestion-proxy
  - package.json
autonomous: true
requirements: [RATE-01]

must_haves:
  truths:
    - "Ingestion proxy service runs independently on port 3000"
    - "Proxy route accepts POST /graphql with authentication"
    - "Rate limiter enforces 25 req/s global limit"
    - "Service builds successfully with Docker"
  artifacts:
    - path: "apps/ingestion-proxy/src/index.ts"
      provides: "Express server bootstrap with graceful shutdown"
      min_lines: 40
    - path: "apps/ingestion-proxy/src/routes/proxy.ts"
      provides: "GraphQL proxy route with rate limiting"
      exports: ["default"]
    - path: "apps/ingestion-proxy/src/middleware/auth.ts"
      provides: "Internal service token authentication"
      exports: ["nivodaProxyAuth"]
    - path: "docker/Dockerfile.ingestion-proxy"
      provides: "Multi-stage Docker build"
      min_lines: 30
  key_links:
    - from: "apps/ingestion-proxy/src/index.ts"
      to: "apps/ingestion-proxy/src/routes/proxy.ts"
      via: "Express router mount at /graphql"
      pattern: "app\\.use.*proxy"
    - from: "apps/ingestion-proxy/src/routes/proxy.ts"
      to: "packages/api/src/middleware/rateLimiter.ts"
      via: "createRateLimiterMiddleware import"
      pattern: "createRateLimiterMiddleware"
    - from: "docker/Dockerfile.ingestion-proxy"
      to: "apps/ingestion-proxy/dist/index.js"
      via: "CMD instruction"
      pattern: 'CMD.*ingestion-proxy/dist/index\\.js'
---

<objective>
Create standalone ingestion-proxy service by extracting Nivoda proxy route from customer API into dedicated Express application.

Purpose: Establish single-replica bottleneck for global 25 req/s rate limiting to Nivoda, enabling customer API to scale independently.

Output: New workspace package `@diamond/ingestion-proxy` with HTTP server, proxy route, auth middleware, and Docker build.
</objective>

<execution_context>
@/Users/shaunnesbitt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shaunnesbitt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rate-limiting-separation/01-RESEARCH.md

# Existing files to extract from
@packages/api/src/routes/nivodaProxy.ts
@packages/api/src/middleware/nivodaProxyAuth.ts
@packages/api/src/middleware/rateLimiter.ts
@docker/Dockerfile.api
</context>

<tasks>

<task type="auto">
  <name>Create ingestion-proxy package structure</name>
  <files>
apps/ingestion-proxy/package.json
apps/ingestion-proxy/tsconfig.json
apps/ingestion-proxy/src/index.ts
package.json
  </files>
  <action>
Create new workspace package at `apps/ingestion-proxy/`:

1. **package.json** - Name `@diamond/ingestion-proxy`, private workspace package, dependencies: `express`, `@types/express`, `@diamond/shared`, scripts: `build` (tsc), `dev` (tsx watch), `start` (node dist/index.js)

2. **tsconfig.json** - Extend from `../../tsconfig.json`, set `outDir: "dist"`, `rootDir: "src"`, ES2022 target, ESNext module

3. **src/index.ts** - Express server bootstrap:
   - Import express, createServiceLogger from @diamond/shared
   - Create app, configure JSON parsing (max 1MB body)
   - Mount proxy route at `/graphql`
   - Health check endpoint GET `/health` → 200 "OK"
   - Start server on PORT env var (default 3000)
   - Graceful shutdown handler (SIGTERM/SIGINT) with 10s timeout
   - Log server start/stop events with traceId

4. Update root `package.json` workspaces array to include `apps/ingestion-proxy`

Follow pattern from existing apps (scheduler, worker, consolidator) for workspace structure.
  </action>
  <verify>
```bash
cat apps/ingestion-proxy/package.json | grep '"name": "@diamond/ingestion-proxy"'
cat apps/ingestion-proxy/src/index.ts | grep -E '(express|graceful shutdown|health)'
npm install
npm run build -w @diamond/ingestion-proxy
```
  </verify>
  <done>
- Package builds successfully without errors
- TypeScript compilation produces dist/index.js
- Workspace recognized in root package.json
  </done>
</task>

<task type="auto">
  <name>Extract proxy route and auth middleware</name>
  <files>
apps/ingestion-proxy/src/routes/proxy.ts
apps/ingestion-proxy/src/middleware/auth.ts
  </files>
  <action>
Extract existing proxy implementation:

1. **src/middleware/auth.ts** - Copy from `packages/api/src/middleware/nivodaProxyAuth.ts`:
   - Import timingSafeEqual from crypto, requireEnv/createServiceLogger from @diamond/shared
   - Export `nivodaProxyAuth` middleware function
   - Check `x-internal-token` header against `INTERNAL_SERVICE_TOKEN` env var
   - Use constant-time comparison (timingSafeEqual)
   - Return 401 if missing/invalid, log auth events
   - Preserve existing traceId propagation logic

2. **src/routes/proxy.ts** - Extract from `packages/api/src/routes/nivodaProxy.ts`:
   - Import Router from express, nivodaProxyAuth from middleware
   - Import createRateLimiterMiddleware from @diamond/shared (NOT from packages/api)
   - Import constants: NIVODA_PROXY_RATE_LIMIT, NIVODA_PROXY_RATE_LIMIT_WINDOW_MS, NIVODA_PROXY_RATE_LIMIT_MAX_WAIT_MS, NIVODA_PROXY_TIMEOUT_MS
   - Create rate limiter with config (25 req/s, 1000ms window, 60s max wait)
   - POST /graphql route with middleware chain: nivodaProxyAuth → rateLimiter → handler
   - Preserve complete proxy logic: query validation, size checks, Nivoda fetch, error handling
   - Preserve traceId propagation and structured logging
   - Default export router

NOTE: Rate limiter middleware already exists in `packages/api/src/middleware/rateLimiter.ts`. Move this to `packages/shared/src/middleware/` for reuse (create middleware directory if needed), or import directly from packages/api for now.
  </action>
  <verify>
```bash
grep -q "nivodaProxyAuth" apps/ingestion-proxy/src/middleware/auth.ts
grep -q "createRateLimiterMiddleware" apps/ingestion-proxy/src/routes/proxy.ts
grep -q "NIVODA_PROXY_RATE_LIMIT" apps/ingestion-proxy/src/routes/proxy.ts
npm run typecheck -w @diamond/ingestion-proxy
```
  </verify>
  <done>
- Auth middleware exports nivodaProxyAuth function
- Proxy route uses auth + rate limiter middleware chain
- TypeScript compilation succeeds
- Import from @diamond/shared compiles (rate limiter available)
  </done>
</task>

<task type="auto">
  <name>Create Docker build for ingestion-proxy</name>
  <files>
docker/Dockerfile.ingestion-proxy
  </files>
  <action>
Create multi-stage Dockerfile following pattern from `docker/Dockerfile.api`:

**Stage 1 (builder):**
- FROM node:20-alpine AS builder
- WORKDIR /app
- Copy package*.json, tsconfig*.json
- Copy packages/ and apps/ingestion-proxy/
- RUN npm ci (install all workspace dependencies)
- RUN npm run build -w @diamond/ingestion-proxy

**Stage 2 (production):**
- FROM node:20-alpine
- WORKDIR /app
- Copy from builder: node_modules, packages (compiled), apps/ingestion-proxy/dist, apps/ingestion-proxy/package.json
- ENV NODE_ENV=production
- ENV PORT=3000
- EXPOSE 3000
- CMD ["node", "apps/ingestion-proxy/dist/index.js"]

Match structure of Dockerfile.api but only copy ingestion-proxy app (not api, worker, etc).
  </action>
  <verify>
```bash
grep -q "FROM node:20-alpine AS builder" docker/Dockerfile.ingestion-proxy
grep -q "npm run build -w @diamond/ingestion-proxy" docker/Dockerfile.ingestion-proxy
grep -q 'CMD \["node", "apps/ingestion-proxy/dist/index.js"\]' docker/Dockerfile.ingestion-proxy
docker build -f docker/Dockerfile.ingestion-proxy -t diamond-ingestion-proxy:test .
```
  </verify>
  <done>
- Dockerfile builds successfully
- Image size reasonable (~150-200MB compressed)
- CMD points to ingestion-proxy dist/index.js
  </done>
</task>

</tasks>

<verification>
Overall plan verification:

```bash
# Workspace builds
npm run build

# Ingestion proxy compiles
npm run typecheck -w @diamond/ingestion-proxy

# Docker image builds
docker build -f docker/Dockerfile.ingestion-proxy -t diamond-ingestion-proxy:test .

# Verify file structure
ls apps/ingestion-proxy/src/index.ts
ls apps/ingestion-proxy/src/routes/proxy.ts
ls apps/ingestion-proxy/src/middleware/auth.ts
```

Expected output:
- All TypeScript files compile without errors
- Docker build completes successfully
- File structure matches research patterns
</verification>

<success_criteria>
1. New `@diamond/ingestion-proxy` workspace package exists
2. Package builds successfully with `npm run build`
3. Docker image builds successfully with Dockerfile.ingestion-proxy
4. Proxy route extracted with auth + rate limiter middleware
5. Server includes health check endpoint at /health
6. Graceful shutdown handling implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-rate-limiting-separation/01-01-SUMMARY.md`
</output>
